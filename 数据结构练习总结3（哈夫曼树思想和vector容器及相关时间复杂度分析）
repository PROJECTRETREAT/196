/*
题目如下：
农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数L​i个长度单位，于是他购买了一条很长的、能锯成N块的木头，
即该木头的长度是L​i 的总和。但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。
例如，要将长度为20的木头锯成长度为8、7和5的三段，第一次锯木头花费20，将木头锯成12和8；第二次锯木头花费12，将长度为12的木头锯成7和5，
总花费为32。如果第一次将木头锯成15和5，则第二次锯木头花费15，总花费为35（大于32）。
请编写程序帮助农夫计算将木头锯成N块的最少花费。
输入格式:
输入首先给出正整数N（≤104），表示要将木头锯成N块。第二行给出N个正整数（≤50），表示每段木块的长度。
输出格式:
输出一个整数，即将木头锯成N块的最少花费。
输入样例:
8
4 5 1 2 1 3 1 1
输出样例:
49

题目目的是让花费最少，而这个花费就是每次切的长度之和，而哈夫曼树是带权路径最短的树，而权正好相当于切后两块木板长度和，所以费用就是哈夫曼树中所有权之和，
所以用需要的木板长度构建哈夫曼树，再求权和即可。

用stl中的vector容器代替树：
*/

#include<bits/stdc++.h>
using namespace std;
#define maxlen 10000000
int main()
{
	int n,a;
	cin >> n;
	vector<int>v;
	while (n--)
	{
		cin >> a;
		v.push_back(a);
	}
	int sum = 0;
	for (;;)  //projectA代码
	{
		vector<int>::iterator x = min_element(v.begin(), v.end());
		int temp1 = *x;
		*x = maxlen;
		vector<int>::iterator y = min_element(v.begin(), v.end());
		if (*y == (maxlen))
			break;
		int temp2=*y;
		*y = maxlen;
		sum += temp1 + temp2;
		v.push_back(temp1 + temp2);
		//*y = maxlen;
	}
	/*	projectB代码
	while (v.size() != 1)
	{
		vector<int>::iterator x = min_element(v.begin(), v.end());
		int a = *x;
		v.erase(x);
		vector<int>::iterator y = min_element(v.begin(), v.end());
		int b = *y;
		v.erase(y);
		sum += a+b;
		v.push_back(a+b);
	}*/
	cout << sum;
	return 0;
}


/*代码中第27行的*y = maxlen不能写在这个位置，只能写在第24行，因为上一行对vector进行了操作，一旦对容器操作后，之前定义的迭代器就不能再使用了，
会出现 vector iterator not dereferencable 的迭代器越界，这个耽误了我很久。
代码中29行–40行的projectB代码可以替代15行–28行projectA代码，但是vector容器是类似数组的顺序类容器，所以进行在非尾部进行增删操作时实际上会耗时较多，
所以projectB中的erase函数会影响时间复杂度，而projectA中采用将使用过的元素（子节点）置为足够大的数，再用条件语句跳出循环，按理说能够更快的完成任务。
但是erase函数和remove函数不同，erase函数会减少vector的长度，remove函数则是移开删除元素，不会减少长度，而两个方法中都有min_element函数，
这个函数的执行时间也与vector的长度有关，时间复杂度应该O（n），所以在这里projectB又更优了，经过测试，在n即需求木板数较少时，projectA更优，
而在较大时，projectB更优
*/
